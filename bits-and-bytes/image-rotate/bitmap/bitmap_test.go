package bitmap

import (
	"bytes"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
)

var (
	squarePixels = []byte{
		0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
		0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,
		0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,
	}
	squareInfo = []byte{
		0x28, 0x00, 0x00, 0x00, // Length of info header
		0x04, 0x00, 0x00, 0x00, // Width
		0x04, 0x00, 0x00, 0x00, // Height
		0x01, 0x00, // Planes
		0x18, 0x00, // Bits per pixel
		0, 0x00, 0x00, 0x00, // Compression
		0x30, 0x00, 0x00, 0, // Size of image (48 bytes)
		0x13, 0x0B, 0x00, 0x00, // Horizontal resolution
		0x13, 0x0B, 0x00, 0x00, // Vertical resoltuion
		0, 0x00, 0x00, 0x00, // Colors in the palette
		0, 0x00, 0x00, 0x00, // Important colors
	}
	squareHeader = []byte{
		0x42, 0x4D, // ID Field ("BM")
		0x66, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, // Unused
		0x36, 0x00, 0x00, 0x00, // Pixel array offset
	}
	squareHeadersBytes = append(squareHeader, squareInfo...)
	squareBmpBytes     = append(squareHeadersBytes, squarePixels...)
	squareBmp          = NewFromReader(bytes.NewReader(squareBmpBytes))
	rectPixels         = []byte{
		0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
		0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
		0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	rectInfo = []byte{
		0x28, 0x00, 0x00, 0x00, // Length of info header
		0x05, 0x00, 0x00, 0x00, // Width
		0x03, 0x00, 0x00, 0x00, // Height
		0x01, 0x00, // Planes
		0x18, 0x00, // Bits per pixel
		0x00, 0x00, 0x00, 0x00, // Compression
		0x30, 0x00, 0x00, 0x00, // Size of image (48 bytes)
		0x13, 0x0B, 0x00, 0x00, // Horizontal resolution
		0x13, 0x0B, 0x00, 0x00, // Vertical resoltuion
		0x00, 0x00, 0x00, 0x00, // Colors in the palette
		0x00, 0x00, 0x00, 0x00, // Important colors
	}
	rectHeader = []byte{
		0x42, 0x4D, // ID Field ("BM")
		0x66, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, // Unused
		0x36, 0x00, 0x00, 0x00, // Pixel array offset
	}
	rectHeadersBytes = append(rectHeader, rectInfo...)
	rectBmpBytes     = append(rectHeadersBytes, rectPixels...)
	rectBmp          = NewFromReader(bytes.NewReader(rectBmpBytes))
)

// TestSaveBitmap can be unskipped to verify that saving a BMP is successful
func TestSaveBitmap(t *testing.T) {
	// t.Skip()
	f, err := os.Create("test_rect.bmp")
	if err != nil {
		t.Fatalf("%s", err)
	}
	defer f.Close()

	toWrite := [][]byte{rectHeader, rectInfo, rectPixels}

	for _, slice := range toWrite {
		n, err := f.Write(slice)
		if err != nil {
			t.Fatalf("%s", err)
		}
		if n != len(slice) {
			t.Fatalf("Expected %d bytes, but got %d", len(slice), n)
		}
	}
}

// Tests that a new bitmap struct is created from a reader
func TestNewFromReader(t *testing.T) {
	assert.Equal(t, int32(4), squareBmp.Width)
	assert.Equal(t, int32(4), squareBmp.Height)
	assert.Equal(t, uint32(40), squareBmp.InfoSize)
	assert.Equal(t, uint32(54), squareBmp.Offset)
	assert.Equal(t, []byte{0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00}, squareBmp.Image[0:12])
}

func TestRotateSquare(t *testing.T) {
	testCases := []struct {
		bmp          Bitmap
		expWidth     int32
		expHeight    int32
		expInfoSize  uint32
		expOffset    uint32
		bottomRow    []byte
		lastSixBytes []byte
	}{
		{squareBmp, 4, 4, 40, 54,
			[]byte{0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff},
			[]byte{0x00, 0xff, 0x00, 0x00, 0xff, 0x00},
		},
		{rectBmp, 3, 5, 40, 54,
			[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			[]byte{0x00, 0x00, 0xff, 0x00, 0x00, 0x00},
		},
	}

	for _, tc := range testCases {
		rotated := Rotate(tc.bmp)
		assert.Equal(t, tc.expWidth, rotated.Width)
		assert.Equal(t, tc.expHeight, rotated.Height)
		assert.Equal(t, tc.expInfoSize, rotated.InfoSize)
		assert.Equal(t, tc.expOffset, rotated.Offset)
		bytesPerRow := rotated.Width * 3
		padding := (4 - (rotated.Width*3)%4) % 4
		bytesPerRow += padding
		assert.Equal(t, tc.bottomRow, rotated.Image[0:bytesPerRow])
		assert.Equal(t, tc.lastSixBytes, rotated.Image[len(rotated.Image)-6:len(rotated.Image)])
	}
}
